<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Real World Algorithms: graph&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Real World Algorithms
   </div>
   <div id="projectbrief">Examples and Tasks and visualisation while reading Real-World Algorithms - Panos Louridas book</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structgraph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structgraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">graph&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Template class consisted graph data and some functions to work with.  
 <a href="structgraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_real___world___algorithms_8h_source.html">Real_World_Algorithms.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1cea22554ea9deb14e7c9f9be748ffb"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#ab1cea22554ea9deb14e7c9f9be748ffb">getLastVisitedNode</a> ()</td></tr>
<tr class="memdesc:ab1cea22554ea9deb14e7c9f9be748ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return last visited node value.  <a href="structgraph.html#ab1cea22554ea9deb14e7c9f9be748ffb">More...</a><br /></td></tr>
<tr class="separator:ab1cea22554ea9deb14e7c9f9be748ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edfb00a794cb5321e2980ecfb494fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a4edfb00a794cb5321e2980ecfb494fc8">getNumberCurrentPath</a> ()</td></tr>
<tr class="memdesc:a4edfb00a794cb5321e2980ecfb494fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Povide flag for DFS search graph visualisation.  <a href="structgraph.html#a4edfb00a794cb5321e2980ecfb494fc8">More...</a><br /></td></tr>
<tr class="separator:a4edfb00a794cb5321e2980ecfb494fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62535139e72190270f5786c085a358d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a62535139e72190270f5786c085a358d0">getLastVisitedNodeColor</a> ()</td></tr>
<tr class="memdesc:a62535139e72190270f5786c085a358d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return color of last visited node for red-black(true-false) graph.  <a href="structgraph.html#a62535139e72190270f5786c085a358d0">More...</a><br /></td></tr>
<tr class="separator:a62535139e72190270f5786c085a358d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21ba55a7dd033f41f80464c4adfbce4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#ad21ba55a7dd033f41f80464c4adfbce4">graph</a> (size_t N_)</td></tr>
<tr class="memdesc:ad21ba55a7dd033f41f80464c4adfbce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="structgraph.html#ad21ba55a7dd033f41f80464c4adfbce4">More...</a><br /></td></tr>
<tr class="separator:ad21ba55a7dd033f41f80464c4adfbce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7c56616b580fb6c7c0fd3e6927d117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a3a7c56616b580fb6c7c0fd3e6927d117">graph</a> (<a class="el" href="structgraph.html">graph</a>&lt; T &gt; &amp;gr_)</td></tr>
<tr class="memdesc:a3a7c56616b580fb6c7c0fd3e6927d117"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="structgraph.html#a3a7c56616b580fb6c7c0fd3e6927d117">More...</a><br /></td></tr>
<tr class="separator:a3a7c56616b580fb6c7c0fd3e6927d117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83d068f4a997e9430e713b100aafc5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#af83d068f4a997e9430e713b100aafc5e">RAND</a> (int left, int right)</td></tr>
<tr class="memdesc:af83d068f4a997e9430e713b100aafc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform distributed random int value generated with mt19937  <a href="structgraph.html#af83d068f4a997e9430e713b100aafc5e">More...</a><br /></td></tr>
<tr class="separator:af83d068f4a997e9430e713b100aafc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d2f7db6d6dc43257cf6ae429b42174"><td class="memItemLeft" align="right" valign="top"><a id="a87d2f7db6d6dc43257cf6ae429b42174"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a87d2f7db6d6dc43257cf6ae429b42174">cleanup</a> ()</td></tr>
<tr class="memdesc:a87d2f7db6d6dc43257cf6ae429b42174"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear all members of this graph to zero states <br /></td></tr>
<tr class="separator:a87d2f7db6d6dc43257cf6ae429b42174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ded5d943159ae0a76f8b63a24220d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a1ded5d943159ae0a76f8b63a24220d58">isVisitedTrue</a> ()</td></tr>
<tr class="memdesc:a1ded5d943159ae0a76f8b63a24220d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if all nodes of graph was visited  <a href="structgraph.html#a1ded5d943159ae0a76f8b63a24220d58">More...</a><br /></td></tr>
<tr class="separator:a1ded5d943159ae0a76f8b63a24220d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b9127855c1caeddfd7f2eba865baa1"><td class="memItemLeft" align="right" valign="top"><a id="a94b9127855c1caeddfd7f2eba865baa1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a94b9127855c1caeddfd7f2eba865baa1">print</a> ()</td></tr>
<tr class="memdesc:a94b9127855c1caeddfd7f2eba865baa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">print all graph edges and vertexes to std::cout <br /></td></tr>
<tr class="separator:a94b9127855c1caeddfd7f2eba865baa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4276014586473e221281a1d8ea1bc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a1d4276014586473e221281a1d8ea1bc4">print_to_string</a> ()</td></tr>
<tr class="memdesc:a1d4276014586473e221281a1d8ea1bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">print all graph edges and vertexes to std::string  <a href="structgraph.html#a1d4276014586473e221281a1d8ea1bc4">More...</a><br /></td></tr>
<tr class="separator:a1d4276014586473e221281a1d8ea1bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfadb5eff2b1d5aacd87e38c335a140a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#abfadb5eff2b1d5aacd87e38c335a140a">makeAdjacencyList</a> (int node)</td></tr>
<tr class="memdesc:abfadb5eff2b1d5aacd87e38c335a140a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vector with adjacency vertexes in graph for current node. Nodes already visited excluded.  <a href="structgraph.html#abfadb5eff2b1d5aacd87e38c335a140a">More...</a><br /></td></tr>
<tr class="separator:abfadb5eff2b1d5aacd87e38c335a140a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad0a152d0872f9d411b80ab51484af2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a7ad0a152d0872f9d411b80ab51484af2">makeAdjacencyList2</a> (int node)</td></tr>
<tr class="memdesc:a7ad0a152d0872f9d411b80ab51484af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vector with adjacency vertexes in graph for current node.  <a href="structgraph.html#a7ad0a152d0872f9d411b80ab51484af2">More...</a><br /></td></tr>
<tr class="separator:a7ad0a152d0872f9d411b80ab51484af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4ba24846ef391e48e699fce5553521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#adf4ba24846ef391e48e699fce5553521">DFS_recurcive</a> (int node, std::function&lt; void()&gt; visualisation_func=[]{})</td></tr>
<tr class="memdesc:adf4ba24846ef391e48e699fce5553521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search recurcive algorithm for this graph.  <a href="structgraph.html#adf4ba24846ef391e48e699fce5553521">More...</a><br /></td></tr>
<tr class="separator:adf4ba24846ef391e48e699fce5553521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfe5e7b91eee64d63b729bfed7a669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#ab5bfe5e7b91eee64d63b729bfed7a669">DFS_stack</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:ab5bfe5e7b91eee64d63b729bfed7a669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search stack algorithm for this graph.  <a href="structgraph.html#ab5bfe5e7b91eee64d63b729bfed7a669">More...</a><br /></td></tr>
<tr class="separator:ab5bfe5e7b91eee64d63b729bfed7a669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e287c37258adbc6f6fab2fb8c4ee1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#ad4e287c37258adbc6f6fab2fb8c4ee1d">DFS_stack_2</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:ad4e287c37258adbc6f6fab2fb8c4ee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search stack algorithm for this graph, work without visiting the nodes which was already have been visited.  <a href="structgraph.html#ad4e287c37258adbc6f6fab2fb8c4ee1d">More...</a><br /></td></tr>
<tr class="separator:ad4e287c37258adbc6f6fab2fb8c4ee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75186f270f7284d34719ed65efe9fb23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a75186f270f7284d34719ed65efe9fb23">DFS_stack_2_random</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:a75186f270f7284d34719ed65efe9fb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">it is like Depth-First Search stack algorithm. The next node chose only one and randomly from avaliable in adjacency list. After no avalible nodes in adjacency list presented for next step random vertex on graph chosed and etc. while all vertexes have not been visited.  <a href="structgraph.html#a75186f270f7284d34719ed65efe9fb23">More...</a><br /></td></tr>
<tr class="separator:a75186f270f7284d34719ed65efe9fb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dee4d3ffad5f309d9df82c12b68fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a68dee4d3ffad5f309d9df82c12b68fce">BFS</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:a68dee4d3ffad5f309d9df82c12b68fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-First Search algorithm for this graph.  <a href="structgraph.html#a68dee4d3ffad5f309d9df82c12b68fce">More...</a><br /></td></tr>
<tr class="separator:a68dee4d3ffad5f309d9df82c12b68fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa5fbbc3d6e7118d611c920313ddd2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph.html#a1fa5fbbc3d6e7118d611c920313ddd2d">bipartiteGraphCheck</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:a1fa5fbbc3d6e7118d611c920313ddd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">BFS search using on this graph where during it checks if graph bipartite or not.  <a href="structgraph.html#a1fa5fbbc3d6e7118d611c920313ddd2d">More...</a><br /></td></tr>
<tr class="separator:a1fa5fbbc3d6e7118d611c920313ddd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3aa049e2c9a1cf28bfbfba98ab232827"><td class="memItemLeft" align="right" valign="top"><a id="a3aa049e2c9a1cf28bfbfba98ab232827"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>N</b> = 10</td></tr>
<tr class="separator:a3aa049e2c9a1cf28bfbfba98ab232827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266036d11493991142363c25f8f48d28"><td class="memItemLeft" align="right" valign="top"><a id="a266036d11493991142363c25f8f48d28"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>V</b></td></tr>
<tr class="separator:a266036d11493991142363c25f8f48d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4cf705640e9385f2e29d11196e89b8"><td class="memItemLeft" align="right" valign="top"><a id="a3e4cf705640e9385f2e29d11196e89b8"></a>
std::vector&lt; std::pair&lt; T, T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>E</b></td></tr>
<tr class="separator:a3e4cf705640e9385f2e29d11196e89b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de440fceb5e84617f72dc4db8364ed4"><td class="memItemLeft" align="right" valign="top"><a id="a0de440fceb5e84617f72dc4db8364ed4"></a>
std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>visited</b></td></tr>
<tr class="separator:a0de440fceb5e84617f72dc4db8364ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea14e269984f5ed2077469340277987"><td class="memItemLeft" align="right" valign="top"><a id="a2ea14e269984f5ed2077469340277987"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>first_DFS_iteration</b> = true</td></tr>
<tr class="separator:a2ea14e269984f5ed2077469340277987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3d339961604a2e838f733d8e8be49e"><td class="memItemLeft" align="right" valign="top"><a id="aae3d339961604a2e838f733d8e8be49e"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>last_visited_node</b> =T(0)</td></tr>
<tr class="separator:aae3d339961604a2e838f733d8e8be49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab907f59507f301f36e833761d71196"><td class="memItemLeft" align="right" valign="top"><a id="a8ab907f59507f301f36e833761d71196"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>last_visited_node_color</b> =false</td></tr>
<tr class="separator:a8ab907f59507f301f36e833761d71196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d36a85a707ab9e94b4111aca30ef43"><td class="memItemLeft" align="right" valign="top"><a id="a02d36a85a707ab9e94b4111aca30ef43"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>number_path_started</b> = 0</td></tr>
<tr class="separator:a02d36a85a707ab9e94b4111aca30ef43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct graph&lt; T &gt;</h3>

<p>Template class consisted graph data and some functions to work with. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of graph vertexes data </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad21ba55a7dd033f41f80464c4adfbce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21ba55a7dd033f41f80464c4adfbce4">&#9670;&nbsp;</a></span>graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph.html">graph</a>&lt; T &gt;::<a class="el" href="structgraph.html">graph</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N_</td><td>number of vertexes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a7c56616b580fb6c7c0fd3e6927d117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7c56616b580fb6c7c0fd3e6927d117">&#9670;&nbsp;</a></span>graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph.html">graph</a>&lt; T &gt;::<a class="el" href="structgraph.html">graph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph.html">graph</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gr_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gr_</td><td>reference to another grpaph </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a68dee4d3ffad5f309d9df82c12b68fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dee4d3ffad5f309d9df82c12b68fce">&#9670;&nbsp;</a></span>BFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::BFS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breadth-First Search algorithm for this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fa5fbbc3d6e7118d611c920313ddd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa5fbbc3d6e7118d611c920313ddd2d">&#9670;&nbsp;</a></span>bipartiteGraphCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::bipartiteGraphCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BFS search using on this graph where during it checks if graph bipartite or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if graph is bipartite and false otherwise </dd></dl>

</div>
</div>
<a id="adf4ba24846ef391e48e699fce5553521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4ba24846ef391e48e699fce5553521">&#9670;&nbsp;</a></span>DFS_recurcive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::DFS_recurcive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth-First Search recurcive algorithm for this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5bfe5e7b91eee64d63b729bfed7a669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5bfe5e7b91eee64d63b729bfed7a669">&#9670;&nbsp;</a></span>DFS_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::DFS_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth-First Search stack algorithm for this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4e287c37258adbc6f6fab2fb8c4ee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e287c37258adbc6f6fab2fb8c4ee1d">&#9670;&nbsp;</a></span>DFS_stack_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::DFS_stack_2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth-First Search stack algorithm for this graph, work without visiting the nodes which was already have been visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75186f270f7284d34719ed65efe9fb23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75186f270f7284d34719ed65efe9fb23">&#9670;&nbsp;</a></span>DFS_stack_2_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::DFS_stack_2_random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it is like Depth-First Search stack algorithm. The next node chose only one and randomly from avaliable in adjacency list. After no avalible nodes in adjacency list presented for next step random vertex on graph chosed and etc. while all vertexes have not been visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1cea22554ea9deb14e7c9f9be748ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cea22554ea9deb14e7c9f9be748ffb">&#9670;&nbsp;</a></span>getLastVisitedNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::getLastVisitedNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return last visited node value. </p>
<dl class="section return"><dt>Returns</dt><dd>Last visited node </dd></dl>

</div>
</div>
<a id="a62535139e72190270f5786c085a358d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62535139e72190270f5786c085a358d0">&#9670;&nbsp;</a></span>getLastVisitedNodeColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::getLastVisitedNodeColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return color of last visited node for red-black(true-false) graph. </p>
<dl class="section return"><dt>Returns</dt><dd>Bool value of color. </dd></dl>

</div>
</div>
<a id="a4edfb00a794cb5321e2980ecfb494fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edfb00a794cb5321e2980ecfb494fc8">&#9670;&nbsp;</a></span>getNumberCurrentPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::getNumberCurrentPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Povide flag for DFS search graph visualisation. </p>
<dl class="section return"><dt>Returns</dt><dd>Current number of path started value </dd></dl>

</div>
</div>
<a id="a1ded5d943159ae0a76f8b63a24220d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ded5d943159ae0a76f8b63a24220d58">&#9670;&nbsp;</a></span>isVisitedTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::isVisitedTrue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if all nodes of graph was visited </p>
<dl class="section return"><dt>Returns</dt><dd>true if all nodes visited </dd></dl>

</div>
</div>
<a id="abfadb5eff2b1d5aacd87e38c335a140a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfadb5eff2b1d5aacd87e38c335a140a">&#9670;&nbsp;</a></span>makeAdjacencyList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::makeAdjacencyList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct vector with adjacency vertexes in graph for current node. Nodes already visited excluded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>current node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; of adjacency vertexes </dd></dl>

</div>
</div>
<a id="a7ad0a152d0872f9d411b80ab51484af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad0a152d0872f9d411b80ab51484af2">&#9670;&nbsp;</a></span>makeAdjacencyList2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::makeAdjacencyList2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct vector with adjacency vertexes in graph for current node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>current node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; of adjacency vertexes </dd></dl>

</div>
</div>
<a id="a1d4276014586473e221281a1d8ea1bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4276014586473e221281a1d8ea1bc4">&#9670;&nbsp;</a></span>print_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::print_to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print all graph edges and vertexes to std::string </p>
<dl class="section return"><dt>Returns</dt><dd>std::string like "V = {0,1,2} E= {{0,1},{1,2},{0,2}}" </dd></dl>

</div>
</div>
<a id="af83d068f4a997e9430e713b100aafc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83d068f4a997e9430e713b100aafc5e">&#9670;&nbsp;</a></span>RAND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structgraph.html">graph</a>&lt; T &gt;::RAND </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>uniform distributed random int value generated with mt19937 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>left edge in [left,right] range </td></tr>
    <tr><td class="paramname">right</td><td>right edge in [left,right] range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value in setted range </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_real___world___algorithms_8h_source.html">Real_World_Algorithms.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structgraph.html">graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
