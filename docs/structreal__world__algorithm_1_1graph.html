<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Real World Algorithms: real_world_algorithm::graph&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Real World Algorithms
   </div>
   <div id="projectbrief">Examples and Tasks and visualisation while reading Real-World Algorithms - Panos Louridas book</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structreal__world__algorithm_1_1graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structreal__world__algorithm_1_1graph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">real_world_algorithm::graph&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Template class consisted graph data and some functions to work with.  
 <a href="structreal__world__algorithm_1_1graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_real___world___algorithms_8h_source.html">Real_World_Algorithms.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6574226342f057b9da9603017f5c20be"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a6574226342f057b9da9603017f5c20be">getLastVisitedNode</a> ()</td></tr>
<tr class="memdesc:a6574226342f057b9da9603017f5c20be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return last visited node value.  <a href="structreal__world__algorithm_1_1graph.html#a6574226342f057b9da9603017f5c20be">More...</a><br /></td></tr>
<tr class="separator:a6574226342f057b9da9603017f5c20be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd20eba00bdb99db0ae3a05444ae1d0d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#abd20eba00bdb99db0ae3a05444ae1d0d">getNumberCurrentPath</a> ()</td></tr>
<tr class="memdesc:abd20eba00bdb99db0ae3a05444ae1d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Povide flag for DFS search graph visualisation.  <a href="structreal__world__algorithm_1_1graph.html#abd20eba00bdb99db0ae3a05444ae1d0d">More...</a><br /></td></tr>
<tr class="separator:abd20eba00bdb99db0ae3a05444ae1d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa400bcb60ff738252610ba0942b45f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a1aa400bcb60ff738252610ba0942b45f">getLastVisitedNodeColor</a> ()</td></tr>
<tr class="memdesc:a1aa400bcb60ff738252610ba0942b45f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return color of last visited node for red-black(true-false) graph.  <a href="structreal__world__algorithm_1_1graph.html#a1aa400bcb60ff738252610ba0942b45f">More...</a><br /></td></tr>
<tr class="separator:a1aa400bcb60ff738252610ba0942b45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21dda1c45abfe8c179ca3a000e31813"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#aa21dda1c45abfe8c179ca3a000e31813">graph</a> ()</td></tr>
<tr class="memdesc:aa21dda1c45abfe8c179ca3a000e31813"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="structreal__world__algorithm_1_1graph.html#aa21dda1c45abfe8c179ca3a000e31813">More...</a><br /></td></tr>
<tr class="separator:aa21dda1c45abfe8c179ca3a000e31813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea142034f4ff13d066f4dacf7a70029"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#abea142034f4ff13d066f4dacf7a70029">graph</a> (size_t N_)</td></tr>
<tr class="memdesc:abea142034f4ff13d066f4dacf7a70029"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="structreal__world__algorithm_1_1graph.html#abea142034f4ff13d066f4dacf7a70029">More...</a><br /></td></tr>
<tr class="separator:abea142034f4ff13d066f4dacf7a70029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfd8aa02eadec15e99420f6e8694d28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a0dfd8aa02eadec15e99420f6e8694d28">graph</a> (<a class="el" href="structreal__world__algorithm_1_1graph.html">graph</a>&lt; T &gt; &amp;gr_)</td></tr>
<tr class="memdesc:a0dfd8aa02eadec15e99420f6e8694d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="structreal__world__algorithm_1_1graph.html#a0dfd8aa02eadec15e99420f6e8694d28">More...</a><br /></td></tr>
<tr class="separator:a0dfd8aa02eadec15e99420f6e8694d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05393d682c47ff0d7b2470d14d0b7f1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a05393d682c47ff0d7b2470d14d0b7f1a">RAND</a> (int left, int right)</td></tr>
<tr class="memdesc:a05393d682c47ff0d7b2470d14d0b7f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">uniform distributed random int value generated with mt19937  <a href="structreal__world__algorithm_1_1graph.html#a05393d682c47ff0d7b2470d14d0b7f1a">More...</a><br /></td></tr>
<tr class="separator:a05393d682c47ff0d7b2470d14d0b7f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e05c81dee35f7dffc34903e2f3e97ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a5e05c81dee35f7dffc34903e2f3e97ca">cleanup</a> ()</td></tr>
<tr class="memdesc:a5e05c81dee35f7dffc34903e2f3e97ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear all members of this graph to zero states  <a href="structreal__world__algorithm_1_1graph.html#a5e05c81dee35f7dffc34903e2f3e97ca">More...</a><br /></td></tr>
<tr class="separator:a5e05c81dee35f7dffc34903e2f3e97ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094a173a05d08f6661848480302a47c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a094a173a05d08f6661848480302a47c3">isVisitedTrue</a> ()</td></tr>
<tr class="memdesc:a094a173a05d08f6661848480302a47c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if all nodes of graph was visited  <a href="structreal__world__algorithm_1_1graph.html#a094a173a05d08f6661848480302a47c3">More...</a><br /></td></tr>
<tr class="separator:a094a173a05d08f6661848480302a47c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730b3dacfb341e54c22fcb8fae426663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a730b3dacfb341e54c22fcb8fae426663">print</a> ()</td></tr>
<tr class="memdesc:a730b3dacfb341e54c22fcb8fae426663"><td class="mdescLeft">&#160;</td><td class="mdescRight">print all graph edges and vertexes to std::cout  <a href="structreal__world__algorithm_1_1graph.html#a730b3dacfb341e54c22fcb8fae426663">More...</a><br /></td></tr>
<tr class="separator:a730b3dacfb341e54c22fcb8fae426663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b26f50838dbe2a0935b67303259803"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#ac5b26f50838dbe2a0935b67303259803">print_to_string</a> ()</td></tr>
<tr class="memdesc:ac5b26f50838dbe2a0935b67303259803"><td class="mdescLeft">&#160;</td><td class="mdescRight">print all graph edges and vertexes to std::string  <a href="structreal__world__algorithm_1_1graph.html#ac5b26f50838dbe2a0935b67303259803">More...</a><br /></td></tr>
<tr class="separator:ac5b26f50838dbe2a0935b67303259803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fd8e8c178a2cf8f0ca5c008a9e5218"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a> (int node)</td></tr>
<tr class="memdesc:a35fd8e8c178a2cf8f0ca5c008a9e5218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vector with adjacency vertexes in graph for current node. Nodes already visited excluded.  <a href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">More...</a><br /></td></tr>
<tr class="separator:a35fd8e8c178a2cf8f0ca5c008a9e5218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362c51b15d5b432dde220e9329d28c2c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a362c51b15d5b432dde220e9329d28c2c">makeAdjacencyList2</a> (int node)</td></tr>
<tr class="memdesc:a362c51b15d5b432dde220e9329d28c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vector with adjacency vertexes in graph for current node.  <a href="structreal__world__algorithm_1_1graph.html#a362c51b15d5b432dde220e9329d28c2c">More...</a><br /></td></tr>
<tr class="separator:a362c51b15d5b432dde220e9329d28c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13484e52d5d0266284ccedfe2158d778"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a13484e52d5d0266284ccedfe2158d778">DFS_recurcive</a> (int node, std::function&lt; void()&gt; visualisation_func=[]{})</td></tr>
<tr class="memdesc:a13484e52d5d0266284ccedfe2158d778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search recurcive algorithm for this graph.  <a href="structreal__world__algorithm_1_1graph.html#a13484e52d5d0266284ccedfe2158d778">More...</a><br /></td></tr>
<tr class="separator:a13484e52d5d0266284ccedfe2158d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1273edd196b03774fe116e872ec2a895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a1273edd196b03774fe116e872ec2a895">DFS_stack</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:a1273edd196b03774fe116e872ec2a895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search stack algorithm for this graph.  <a href="structreal__world__algorithm_1_1graph.html#a1273edd196b03774fe116e872ec2a895">More...</a><br /></td></tr>
<tr class="separator:a1273edd196b03774fe116e872ec2a895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1aaabd9b04d0f3f83f1190a6a2b2071"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#ac1aaabd9b04d0f3f83f1190a6a2b2071">DFS_stack_2</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:ac1aaabd9b04d0f3f83f1190a6a2b2071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depth-First Search stack algorithm for this graph, work without visiting the nodes which was already have been visited.  <a href="structreal__world__algorithm_1_1graph.html#ac1aaabd9b04d0f3f83f1190a6a2b2071">More...</a><br /></td></tr>
<tr class="separator:ac1aaabd9b04d0f3f83f1190a6a2b2071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964d002588b6db75baa53197163c2115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a964d002588b6db75baa53197163c2115">DFS_stack_2_random</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:a964d002588b6db75baa53197163c2115"><td class="mdescLeft">&#160;</td><td class="mdescRight">it is like Depth-First Search stack algorithm. The next node chose only one and randomly from avaliable in adjacency list. After no avalible nodes in adjacency list presented for next step random vertex on graph chosed and etc. while all vertexes have not been visited.  <a href="structreal__world__algorithm_1_1graph.html#a964d002588b6db75baa53197163c2115">More...</a><br /></td></tr>
<tr class="separator:a964d002588b6db75baa53197163c2115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fb6fbccbe412ab1f73c5e11f2706a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#ac1fb6fbccbe412ab1f73c5e11f2706a3">BFS</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:ac1fb6fbccbe412ab1f73c5e11f2706a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breadth-First Search algorithm for this graph.  <a href="structreal__world__algorithm_1_1graph.html#ac1fb6fbccbe412ab1f73c5e11f2706a3">More...</a><br /></td></tr>
<tr class="separator:ac1fb6fbccbe412ab1f73c5e11f2706a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ec9e117dee02421d24c58a482faf3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreal__world__algorithm_1_1graph.html#a36ec9e117dee02421d24c58a482faf3b">bipartiteGraphCheck</a> (int node, std::function&lt; void()&gt; visualisation_func=[] {})</td></tr>
<tr class="memdesc:a36ec9e117dee02421d24c58a482faf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">BFS search using on this graph where during it checks if graph bipartite or not.  <a href="structreal__world__algorithm_1_1graph.html#a36ec9e117dee02421d24c58a482faf3b">More...</a><br /></td></tr>
<tr class="separator:a36ec9e117dee02421d24c58a482faf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct real_world_algorithm::graph&lt; T &gt;</h3>

<p>Template class consisted graph data and some functions to work with. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of graph vertexes data </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa21dda1c45abfe8c179ca3a000e31813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21dda1c45abfe8c179ca3a000e31813">&#9670;&nbsp;</a></span>graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::<a class="el" href="structreal__world__algorithm_1_1graph.html">graph</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>
<div class="fragment"><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;{};</div>
</div><!-- fragment -->
</div>
</div>
<a id="abea142034f4ff13d066f4dacf7a70029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea142034f4ff13d066f4dacf7a70029">&#9670;&nbsp;</a></span>graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::<a class="el" href="structreal__world__algorithm_1_1graph.html">graph</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N_</td><td>number of vertexes. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;:N(N_) {};</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0dfd8aa02eadec15e99420f6e8694d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfd8aa02eadec15e99420f6e8694d28">&#9670;&nbsp;</a></span>graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::<a class="el" href="structreal__world__algorithm_1_1graph.html">graph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structreal__world__algorithm_1_1graph.html">graph</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>gr_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gr_</td><td>reference to another grpaph </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;    {</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        N = gr_.N;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;        V = gr_.V;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        E = gr_.E;</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1fb6fbccbe412ab1f73c5e11f2706a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1fb6fbccbe412ab1f73c5e11f2706a3">&#9670;&nbsp;</a></span>BFS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::BFS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breadth-First Search algorithm for this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;                                                                    {})</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    {</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160; </div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;        std::vector&lt;bool&gt; inqueue;</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160; </div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;        inqueue.resize(N + 1);</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;        visited.resize(N + 1);</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160; </div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; visited.size(); i++)</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;        {</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;            visited[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;            inqueue[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;        }</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160; </div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;       </div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;BFS: &quot;</span> &lt;&lt; node;</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160; </div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;        ouMyQueue&lt;int&gt; queue(N);</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;        queue.push(node);</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160; </div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;        inqueue[node] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160; </div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;        <span class="keywordflow">while</span> (!queue.is_empty()) {</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            <span class="keyword">auto</span> c = queue.pop();</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;            inqueue[c] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;            visited[c] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            last_visited_node = c;</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;            visualisation_func();</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;            std::vector&lt;int&gt; AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(c);</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a : AdjacencyList)</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;            {</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;                <span class="keywordflow">if</span> (!visited[a] &amp;&amp; !inqueue[a]) {</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;                    std::cout &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; a;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;                    queue.push(a);</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;                    inqueue[a] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;                }</div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;            }</div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;        }<span class="comment">//while</span></div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;    }</div>
<div class="ttc" id="astructreal__world__algorithm_1_1graph_html_a35fd8e8c178a2cf8f0ca5c008a9e5218"><div class="ttname"><a href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">real_world_algorithm::graph::makeAdjacencyList</a></div><div class="ttdeci">std::vector&lt; int &gt; makeAdjacencyList(int node)</div><div class="ttdoc">Construct vector with adjacency vertexes in graph for current node. Nodes already visited excluded.</div><div class="ttdef"><b>Definition:</b> Real_World_Algorithms.h:671</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36ec9e117dee02421d24c58a482faf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ec9e117dee02421d24c58a482faf3b">&#9670;&nbsp;</a></span>bipartiteGraphCheck()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::bipartiteGraphCheck </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BFS search using on this graph where during it checks if graph bipartite or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if graph is bipartite and false otherwise </dd></dl>
<div class="fragment"><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                                                                                   {})</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    {   </div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;      </div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;        <span class="keyword">enum class</span> colors_enum:bool { RED, GREEN } current_color = colors_enum::RED;</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;        <span class="keyword">using</span> <span class="keyword">enum</span> colors_enum;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160; </div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;        std::vector&lt;bool&gt; color;</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;        std::vector&lt;bool&gt; inqueue;</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160; </div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;        inqueue.resize(N+1);</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;        visited.resize(N + 1);</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;        color.resize(N + 1);</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160; </div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; visited.size(); i++)</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;        {</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;            visited[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;            inqueue[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;            </div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;        }</div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160; </div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;BFS_colorify: &quot;</span> &lt;&lt; node;</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160; </div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;        ouMyQueue&lt;int&gt; queue(N);</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;        queue.push(node);</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160; </div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;        inqueue[node] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;        color[node] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(current_color);</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160; </div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;        <span class="keywordflow">while</span> (!queue.is_empty()) {</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;            current_color=(current_color==RED?GREEN:RED);</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;            <span class="keyword">auto</span> c = queue.pop();</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;            inqueue[c] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;            visited[c] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160; </div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;            last_visited_node_color = color[c];</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;            last_visited_node = c;</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;            visualisation_func();</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160; </div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;            std::vector&lt;int&gt; AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(c);</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a : AdjacencyList)</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;            {</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160; </div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;                <span class="keywordflow">if</span> (!visited[a] &amp;&amp; !inqueue[a]) {</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;                    color[a] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">bool</span><span class="keyword">&gt;</span>(current_color);</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;                    std::cout &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; color[a] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                    queue.push(a);</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                    inqueue[a] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;                }</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;               </div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;            }</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;        }<span class="comment">//while</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160; </div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;        <span class="keyword">auto</span> is_colorfied_biportied = [&amp;] {</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160; </div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; v : V) {</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;                <span class="keyword">auto</span> alist = <a class="code" href="structreal__world__algorithm_1_1graph.html#a362c51b15d5b432dde220e9329d28c2c">makeAdjacencyList2</a>(v);</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a : alist)<span class="keywordflow">if</span>(a!=v)<span class="keywordflow">if</span>(color[a] == color[v])<span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;            };</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160; </div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;        };</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160; </div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;        <span class="keyword">auto</span> result = is_colorfied_biportied();</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;;</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;        this-&gt;<a class="code" href="structreal__world__algorithm_1_1graph.html#a730b3dacfb341e54c22fcb8fae426663">print</a>();</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    }</div>
<div class="ttc" id="astructreal__world__algorithm_1_1graph_html_a362c51b15d5b432dde220e9329d28c2c"><div class="ttname"><a href="structreal__world__algorithm_1_1graph.html#a362c51b15d5b432dde220e9329d28c2c">real_world_algorithm::graph::makeAdjacencyList2</a></div><div class="ttdeci">std::vector&lt; int &gt; makeAdjacencyList2(int node)</div><div class="ttdoc">Construct vector with adjacency vertexes in graph for current node.</div><div class="ttdef"><b>Definition:</b> Real_World_Algorithms.h:687</div></div>
<div class="ttc" id="astructreal__world__algorithm_1_1graph_html_a730b3dacfb341e54c22fcb8fae426663"><div class="ttname"><a href="structreal__world__algorithm_1_1graph.html#a730b3dacfb341e54c22fcb8fae426663">real_world_algorithm::graph::print</a></div><div class="ttdeci">void print()</div><div class="ttdoc">print all graph edges and vertexes to std::cout</div><div class="ttdef"><b>Definition:</b> Real_World_Algorithms.h:638</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e05c81dee35f7dffc34903e2f3e97ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e05c81dee35f7dffc34903e2f3e97ca">&#9670;&nbsp;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clear all members of this graph to zero states </p>
<div class="fragment"><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;                   {</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;        V.clear();</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;        E.clear();</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;        visited.clear();</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;        first_DFS_iteration = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;        number_path_started = 0;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160; </div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13484e52d5d0266284ccedfe2158d778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13484e52d5d0266284ccedfe2158d778">&#9670;&nbsp;</a></span>DFS_recurcive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::DFS_recurcive </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth-First Search recurcive algorithm for this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;                                                                            {}) {</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;       <span class="comment">// std::cout &lt;&lt; &quot;getLastVisitedNode() = &quot; &lt;&lt; getLastVisitedNode() &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;        <span class="keywordflow">if</span> (node&lt;0 || node&gt;N) { std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; <span class="stringliteral">&quot; error. first node not in range.&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160; </div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;        <span class="keywordflow">if</span> (first_DFS_iteration) {</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;            visited.resize(N + 1);</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;DFS_Recurcive: &quot;</span>&lt;&lt;node;</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;            first_DFS_iteration = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160; </div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; visited.size(); i++)visited[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;            </div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;        }</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160; </div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;        visited[node] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160; </div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;        last_visited_node = node;</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;        visualisation_func();</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160; </div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;        <span class="keywordtype">bool</span> bl=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> b : visited) { bl = b &amp;&amp; bl; }; </div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;        <span class="keywordflow">if</span> (bl)first_DFS_iteration = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160; </div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;        std::vector&lt;int&gt; AdjacencyList=<a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(node);</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;        <span class="comment">//for (auto&amp; a : AdjacencyList)std::cout &lt;&lt; a &lt;&lt; &quot; &quot;; std::cout &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160; </div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a : AdjacencyList) </div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;            <span class="keywordflow">if</span> (!visited[a]){</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; a;</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;                <a class="code" href="structreal__world__algorithm_1_1graph.html#a13484e52d5d0266284ccedfe2158d778">DFS_recurcive</a>(a, visualisation_func);}</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;    };</div>
<div class="ttc" id="astructreal__world__algorithm_1_1graph_html_a13484e52d5d0266284ccedfe2158d778"><div class="ttname"><a href="structreal__world__algorithm_1_1graph.html#a13484e52d5d0266284ccedfe2158d778">real_world_algorithm::graph::DFS_recurcive</a></div><div class="ttdeci">void DFS_recurcive(int node, std::function&lt; void()&gt; visualisation_func=[]{})</div><div class="ttdoc">Depth-First Search recurcive algorithm for this graph.</div><div class="ttdef"><b>Definition:</b> Real_World_Algorithms.h:702</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1273edd196b03774fe116e872ec2a895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1273edd196b03774fe116e872ec2a895">&#9670;&nbsp;</a></span>DFS_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::DFS_stack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth-First Search stack algorithm for this graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;                                                                         {})</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    {</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;        <span class="keywordflow">if</span> (node&lt;0 || node&gt;N) { std::cout &lt;&lt;__FUNCDNAME__&lt;&lt; <span class="stringliteral">&quot; error. first node not in range.&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;     </div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;        visited.resize(N + 1);</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; visited.size(); i++)visited[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;       <span class="comment">// std::cout &lt;&lt; &quot;DFS_Stack:visited: &quot;; for (auto v : visited)std::cout &lt;&lt; v; std::cout &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;DFS_Stack: &quot;</span> &lt;&lt; node;</div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;        </div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;        ouMyStack&lt;int&gt; stack(N * N);</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;        stack.push(node);</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;        <span class="keywordflow">while</span> (!stack.is_empty()) {</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;            <span class="keyword">auto</span> c = stack.top();</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            stack.pop();</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;            visited[c] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;            last_visited_node = c;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;            visualisation_func();</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;            std::vector&lt;int&gt; AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(c);</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a : AdjacencyList)</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;            {</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;                <span class="keywordflow">if</span> (!visited[a]) {</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; a;</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;                stack.push(a);}</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;            }</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;        };</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1aaabd9b04d0f3f83f1190a6a2b2071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1aaabd9b04d0f3f83f1190a6a2b2071">&#9670;&nbsp;</a></span>DFS_stack_2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::DFS_stack_2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depth-First Search stack algorithm for this graph, work without visiting the nodes which was already have been visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                                                                            {})</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    {</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;        <span class="keywordflow">if</span> (node&lt;0 || node&gt;N) { std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; <span class="stringliteral">&quot; error. first node not in range.&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;        std::vector&lt;int&gt; instack;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160; </div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;        instack.resize(N + 1);</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;        visited.resize(N + 1);</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160; </div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; visited.size(); i++) </div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;        {</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;            visited[i] = <span class="keyword">false</span>; </div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;            instack[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;        }</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160; </div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;        <span class="comment">//std::cout &lt;&lt; &quot;DFS_stack_2:visited: &quot;; for (auto v : visited)std::cout &lt;&lt; v; std::cout &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;DFS_stack_2: &quot;</span> &lt;&lt; node;</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;        </div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;        ouMyStack&lt;int&gt; stack(N * N);</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;        stack.push(node);</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160; </div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;        instack[node] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160; </div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;        <span class="keywordflow">while</span> (!stack.is_empty()) {</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;            <span class="keyword">auto</span> c = stack.top();</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;            stack.pop();</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;            instack[c] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;            visited[c] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;            last_visited_node = c;</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;            visualisation_func();</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;            std::vector&lt;int&gt; AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(c);</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; a : AdjacencyList)</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;            {</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;                <span class="keywordflow">if</span> (!visited[a]&amp;&amp;!instack[a]) {</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;                    std::cout &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; a;</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                    stack.push(a);</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;                    instack[a] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;                }</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;            }</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;        }<span class="comment">//while</span></div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a964d002588b6db75baa53197163c2115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a964d002588b6db75baa53197163c2115">&#9670;&nbsp;</a></span>DFS_stack_2_random()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::DFS_stack_2_random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>visualisation_func</em> = <code>[]&#160;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it is like Depth-First Search stack algorithm. The next node chose only one and randomly from avaliable in adjacency list. After no avalible nodes in adjacency list presented for next step random vertex on graph chosed and etc. while all vertexes have not been visited. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>first node where search begin </td></tr>
    <tr><td class="paramname">visualisation_func</td><td>callback function for extern usage which allow to execute some code during each iteration of search. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;                                                                                   {})</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;    {</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;        <span class="keywordflow">if</span> (node&lt;0 || node&gt;N) { std::cout &lt;&lt; __FUNCDNAME__ &lt;&lt; <span class="stringliteral">&quot; error. first node not in range.&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;        std::vector&lt;bool&gt; instack;</div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;        std::vector&lt;int&gt; not_in_visited;</div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; N; i++)not_in_visited.push_back(i);</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;        instack.resize(N );</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;        visited.resize(N );</div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160; </div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; visited.size(); i++)</div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;        {</div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;            visited[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;            instack[i] = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;        }</div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;        </div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;        ouMyStack&lt;int&gt; stack(N * N);</div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;        stack.push(node);</div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;        instack[node] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;        visited[node] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;        <span class="keyword">auto</span> current = stack.top();</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160; </div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;        <span class="keyword">auto</span> iter = std::find(not_in_visited.begin(), not_in_visited.end(), current);</div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;        <span class="keywordflow">if</span> (iter != not_in_visited.end())</div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;        not_in_visited.erase(iter);</div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160; </div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;        <span class="keywordtype">bool</span> all_visited_true = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;        std::vector&lt;int&gt; AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(current);</div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160; </div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;        <span class="keywordflow">while</span>(!all_visited_true){</div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;            </div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;        <span class="keywordflow">while</span> (AdjacencyList.empty()) {</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;            </div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;            current = not_in_visited[<a class="code" href="structreal__world__algorithm_1_1graph.html#a05393d682c47ff0d7b2470d14d0b7f1a">RAND</a>(0,<span class="keywordtype">int</span>(not_in_visited.size())-1)];</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160; </div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;            AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(current);</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;            <span class="keywordflow">if</span> (AdjacencyList.empty())AdjacencyList.push_back(current);</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;            }</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;            </div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160; </div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;        <span class="keywordflow">while</span> (!AdjacencyList.empty())</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;        {</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;            <span class="keyword">auto</span> r = <a class="code" href="structreal__world__algorithm_1_1graph.html#a05393d682c47ff0d7b2470d14d0b7f1a">RAND</a>(0, <span class="keywordtype">int</span>(AdjacencyList.size()) - 1); <span class="comment">//std::cout &lt;&lt; &quot;AdjacencyList.size() = &quot; &lt;&lt; AdjacencyList.size() &lt;&lt; &quot; RAND(0, AdjacencyList.size()) = &quot; &lt;&lt; r &lt;&lt; std::endl;</span></div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;            current = AdjacencyList[r];</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160; </div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;            <span class="keyword">auto</span> iter = std::find(not_in_visited.begin(), not_in_visited.end(), current);</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;            <span class="keywordflow">if</span> (iter != not_in_visited.end())</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;            not_in_visited.erase(iter);</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160; </div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;            <span class="keywordflow">if</span> (!visited[current] &amp;&amp; !instack[current])</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;            {</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;                stack.push(current);</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;                instack[current] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;                AdjacencyList.clear();</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                AdjacencyList = <a class="code" href="structreal__world__algorithm_1_1graph.html#a35fd8e8c178a2cf8f0ca5c008a9e5218">makeAdjacencyList</a>(current);</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;            }</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;            <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;                <span class="keyword">auto</span> iter = std::find(AdjacencyList.begin(), AdjacencyList.end(), current);</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                <span class="keywordflow">if</span>(iter!=AdjacencyList.end())</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                AdjacencyList.erase(iter);</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            }   </div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;        };</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160; </div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        </div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        <span class="keywordflow">while</span> (!stack.is_empty()) </div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;        {</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;            current = stack.top();</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;            visited[current] = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;            std::cout &lt;&lt; <span class="stringliteral">&quot;-&gt;&quot;</span> &lt;&lt; current;</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;            last_visited_node = current;</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;            visualisation_func();</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;            stack.pop();</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;        </div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;            <span class="keywordflow">if</span>(stack.is_empty())number_path_started++;</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;        }</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160; </div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;        </div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;        <span class="keywordtype">bool</span> bl = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> b : visited) { bl = b &amp;&amp; bl; };</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160; </div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;        <span class="keywordflow">if</span> (bl)all_visited_true = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;        }</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;        number_path_started = 0;</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;        std::cout &lt;&lt; std::endl;</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;    }</div>
<div class="ttc" id="astructreal__world__algorithm_1_1graph_html_a05393d682c47ff0d7b2470d14d0b7f1a"><div class="ttname"><a href="structreal__world__algorithm_1_1graph.html#a05393d682c47ff0d7b2470d14d0b7f1a">real_world_algorithm::graph::RAND</a></div><div class="ttdeci">int RAND(int left, int right)</div><div class="ttdoc">uniform distributed random int value generated with mt19937</div><div class="ttdef"><b>Definition:</b> Real_World_Algorithms.h:610</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6574226342f057b9da9603017f5c20be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6574226342f057b9da9603017f5c20be">&#9670;&nbsp;</a></span>getLastVisitedNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::getLastVisitedNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return last visited node value. </p>
<dl class="section return"><dt>Returns</dt><dd>Last visited node </dd></dl>
<div class="fragment"><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;{ <span class="keywordflow">return</span> last_visited_node;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1aa400bcb60ff738252610ba0942b45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa400bcb60ff738252610ba0942b45f">&#9670;&nbsp;</a></span>getLastVisitedNodeColor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::getLastVisitedNodeColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return color of last visited node for red-black(true-false) graph. </p>
<dl class="section return"><dt>Returns</dt><dd>Bool value of color. </dd></dl>
<div class="fragment"><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;{ <span class="keywordflow">return</span> last_visited_node_color;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd20eba00bdb99db0ae3a05444ae1d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd20eba00bdb99db0ae3a05444ae1d0d">&#9670;&nbsp;</a></span>getNumberCurrentPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::getNumberCurrentPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Povide flag for DFS search graph visualisation. </p>
<dl class="section return"><dt>Returns</dt><dd>Current number of path started value </dd></dl>
<div class="fragment"><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;{ <span class="keywordflow">return</span> number_path_started;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a094a173a05d08f6661848480302a47c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094a173a05d08f6661848480302a47c3">&#9670;&nbsp;</a></span>isVisitedTrue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::isVisitedTrue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if all nodes of graph was visited </p>
<dl class="section return"><dt>Returns</dt><dd>true if all nodes visited </dd></dl>
<div class="fragment"><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;                         {</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        <span class="keywordtype">bool</span> b=<span class="keyword">true</span>;</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> v : visited) b = b &amp;&amp; v;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        <span class="keywordflow">return</span> b;</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a35fd8e8c178a2cf8f0ca5c008a9e5218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fd8e8c178a2cf8f0ca5c008a9e5218">&#9670;&nbsp;</a></span>makeAdjacencyList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::makeAdjacencyList </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct vector with adjacency vertexes in graph for current node. Nodes already visited excluded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>current node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; of adjacency vertexes </dd></dl>
<div class="fragment"><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                                               {</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    </div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        std::vector&lt;int&gt; vec{};</div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : E)</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        {</div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;            <span class="keywordflow">if</span> (e.first == node&amp;&amp;!visited[e.second])vec.push_back(e.second);</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e.second == node &amp;&amp; !visited[e.first])vec.push_back(e.first);</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;        }</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160; </div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        <span class="keywordflow">return</span> std::move(vec);</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160; </div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;    } </div>
</div><!-- fragment -->
</div>
</div>
<a id="a362c51b15d5b432dde220e9329d28c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362c51b15d5b432dde220e9329d28c2c">&#9670;&nbsp;</a></span>makeAdjacencyList2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::makeAdjacencyList2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct vector with adjacency vertexes in graph for current node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>current node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; of adjacency vertexes </dd></dl>
<div class="fragment"><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                                                {</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160; </div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        std::vector&lt;int&gt; vec{};</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : E)</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        {</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;            <span class="keywordflow">if</span> (e.first == node)vec.push_back(e.second);</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (e.second == node)vec.push_back(e.first);</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;        }</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160; </div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;        <span class="keywordflow">return</span> std::move(vec);</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160; </div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a730b3dacfb341e54c22fcb8fae426663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730b3dacfb341e54c22fcb8fae426663">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::print </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print all graph edges and vertexes to std::cout </p>
<div class="fragment"><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;                 {</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;V = { &quot;</span>;</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; v : V)std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot; }&quot;</span> &lt;&lt; std::endl</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;            &lt;&lt; <span class="stringliteral">&quot;E = { &quot;</span>;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : E)std::cout &lt;&lt; <span class="stringliteral">&quot;{&quot;</span> &lt;&lt; e.first &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; e.second &lt;&lt; <span class="stringliteral">&quot;} &quot;</span>;</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot; }&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac5b26f50838dbe2a0935b67303259803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b26f50838dbe2a0935b67303259803">&#9670;&nbsp;</a></span>print_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::print_to_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print all graph edges and vertexes to std::string </p>
<dl class="section return"><dt>Returns</dt><dd>std::string like "V = {0,1,2} E= {{0,1},{1,2},{0,2}}" </dd></dl>
<div class="fragment"><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;    {</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;        std::string result;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;        result+= <span class="stringliteral">&quot;V = { &quot;</span>;</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; v : V) { result += std::to_string(v); result += <span class="stringliteral">&quot; &quot;</span>; }</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;        result += <span class="stringliteral">&quot; } &quot;</span>;</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;        result += <span class="stringliteral">&quot;E = { &quot;</span>;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; e : E)</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;        {</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;            result += <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;            result += std::to_string(e.first);</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;            result += <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;            result += std::to_string(e.second);</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;            result += <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        }</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        result += <span class="stringliteral">&quot;}&quot;</span>;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a05393d682c47ff0d7b2470d14d0b7f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05393d682c47ff0d7b2470d14d0b7f1a">&#9670;&nbsp;</a></span>RAND()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structreal__world__algorithm_1_1graph.html">real_world_algorithm::graph</a>&lt; T &gt;::RAND </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>uniform distributed random int value generated with mt19937 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>left edge in [left,right] range </td></tr>
    <tr><td class="paramname">right</td><td>right edge in [left,right] range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>integer value in setted range </dd></dl>
<div class="fragment"><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    {</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;        std::random_device rd;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;        std::mt19937 gen(rd());</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;        std::uniform_int_distribution&lt;&gt; dist(left, right);</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160; </div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;        <span class="keywordflow">return</span> dist(gen);</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>real_world_algorithm</b></li><li class="navelem"><a class="el" href="structreal__world__algorithm_1_1graph.html">graph</a></li>
    <li class="footer">Generated on Mon Jun 14 2021 12:47:44 for Real World Algorithms by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
